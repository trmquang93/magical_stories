I am an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively.

## Memory Bank

- **The Memory Bank consists of core files and optional context files in Markdown format.** (High)

### Core Files (Required)

- `memory-bank/projectbrief.md` — Foundation document defining core requirements and goals. (High)
- `memory-bank/productContext.md` — Why this project exists and how it should work. (High)
- `memory-bank/activeContext.md` — Current work focus and recent changes. (High)
- `memory-bank/systemPatterns.md` — System architecture and design patterns. (High)
- `memory-bank/techContext.md` — Technologies used and development setup. (High)
- `memory-bank/progress.md` — What works and what's left to build. (High)

### Documentation Updates

- Update Memory Bank when discovering new project patterns. (High)
- Update after significant changes. (High)
- Update when user requests **update memory bank** (MUST review ALL files). (High)
- Update when context needs clarification. (High)

---

## Implementation Rules

### SwiftUI Testing

- **Name test files as `ViewName_Tests.swift`.** (High)
- **Implement Mirror reflection to examine view structure.** (High)
- **Create tests for both initial state and state changes.** (High)
- **Include validation for view hierarchy and content.** (High)
- **Organize tests by view functionality in `magical-storiesTests/Views/*.swift`.** (High)
- **Order tests: basic structure first, state management second, user interaction last.** (High)
- **Use pattern:**  
  ```swift
  Mirror(reflecting: view.body).descendant("content")
  ```  
  (High)
- **Implement async SwiftUI tests:**  
  ```swift
  @Test func testViewState() async throws { ... }
  ```  
  (High)

---

### TDD

- **Use the `@Test` macro for all test methods.** (High)
- **Implement assertions with `#expect`.** (High)
- **Handle optional unwrapping with `#require`.** (High)
- **Create parameterized tests where applicable.** (High)
- **Use appropriate test traits for all test cases.** (High)
- **Group related tests with descriptive naming.** (High)
- **Apply appropriate tags to tests.** (High)
- **Properly handle asynchronous tests.** (High)
- **Follow TDD: write failing tests first, create minimal code to pass, refactor while maintaining test integrity.**  
  Run tests with:  
  ```bash
  ./run_tests.sh
  ```  
  (High)
- **Include `@testable import magical_stories` in test files.** (High)
- **Remember test target and app target are different and require explicit imports.** (High)

---

### Swift Testing Framework

> **Based on:**  
> [Swift Testing Overview](https://developer.apple.com/xcode/swift-testing/)  
> [Testing Framework Documentation](https://developer.apple.com/documentation/testing/)

#### Core Principles

- Use macros for concise, expressive tests
- Support async/throws natively
- Parameterized tests reduce duplication
- Traits and tags customize and organize tests
- Designed for concurrency and parallel execution
- Compatible with XCTest

#### Rules & Examples

- **Always import the `Testing` module at the top of Swift Testing files.** (High)
  ```swift
  import Testing
  ```

- **Declare all tests using `@Test` macro instead of `func testXYZ()`.** (High)
  ```swift
  @Test("Test description here")
  func myTest() { ... }
  ```

- **Provide a descriptive string as the first argument to `@Test`.** (High)  
  ```swift
  @Test("Verify login succeeds with valid credentials")
  func loginSuccessTest() { ... }
  ```

- **Use `arguments:` for parameterized tests.** (High)  
  ```swift
  @Test("Check video titles", arguments: ["A Beach", "By the Lake", "Camping"])
  func videoTitlesTest(title: String) { ... }
  ```

- **Use `#expect` for assertions.** (High)  
  ```swift
  #expect(user.isLoggedIn)
  #expect(score > 0)
  ```

- **Use `#require` for preconditions that must succeed.** (High)  
  ```swift
  let user = try #require(await fetchUser())
  ```

- **Leverage async/throws directly in test signatures.** (High)  
  ```swift
  @Test("Async data fetch test")
  func fetchDataTest() async throws { ... }
  ```

- **Apply traits to customize behavior.** (High)  
  ```swift
  @Test(.enabled(if: FeatureFlags.isEnabled), .timeout(seconds: 5))
  func featureFlagTest() { ... }
  ```

- **Use `.tags()` to categorize tests.** (High)  
  ```swift
  @Test("Payment flow", .tags(.payment, .critical))
  func paymentTest() { ... }
  ```

- **Organize tests hierarchically with nested groups.** (High)  
  ```swift
  group("Authentication") {
      @Test("Valid login") func validLogin() { ... }
      @Test("Invalid login") func invalidLogin() { ... }
  }
  ```

- **Design tests to be concurrency-safe, as they run in parallel by default.** (High)

- **Prefer expressive test names and parameter labels.** (Medium)

- **Use parameterized tests to reduce duplication.** (High)

- **Combine Swift Testing with existing XCTest cases during migration.** (High)

- **Avoid legacy XCTest-only APIs in new tests.** (High)

- **Use `#expect` with operators and expressions.** (High)  
  ```swift
  #expect(result == expected)
  #expect(array.contains(item))
  ```

- **Use `#require` to unwrap optionals safely.** (High)  
  ```swift
  let data = try #require(optionalData)
  ```

- **Annotate async tests with `async throws` and use `await`.** (High)

- **Use traits to enable/disable tests conditionally.** (High)

- **Apply tags to group tests logically.** (High)

- **Keep test bodies concise and focused.** (High)

---

### Documentation Requirements

- Update architecture docs when making architectural changes. (High)
- Update API docs when modifying integrations. (High)
- Update data model docs when changing data structures. (High)
- Update security docs when modifying security aspects. (High)
- Update UI/UX docs when changing interface elements. (High)
- Update feature docs when implementing or modifying features. (High)

---

### Review Process

- Verify all affected documentation has been updated. (High)
- Ensure changes have been reviewed with the team. (High)
- Update version numbers when applicable. (High)
- Validate all code examples in documentation. (High)

---

### Technical

- Within the same target, do not add unnecessary imports. (High)
- Only import external modules/frameworks not in the same target. (High)
- Do not rely solely on IDE linter errors. (Medium)
- Be aware complex Swift features may trigger false linter errors. (Medium)
- Always build the project to validate code correctness. (High)
- Prioritize build errors over linter errors. (High)
- Remember some Swift features cause false positive linter errors. (Medium)

---

## General

- **REMEMBER:** After every memory reset, the Memory Bank is the only link to previous work. Maintain it with precision and clarity. (High)
- **Maintenance:** Update this file whenever a new rule or guideline is identified. (High)

---

# End of `.roo/rules/roorules`