# AI Coding Editor Implementation Rules

When implementing code for this project, follow these specific rules:

## 1. SwiftUI View Testing Implementation

1. Always name test files as `ViewName_Tests.swift`
2. Implement Mirror reflection to examine view structure
3. Create tests for both initial state and state changes
4. Include validation for view hierarchy and content
5. Organize tests by view functionality in the magical-storiesTests/Views/*.swift directory
6. Follow the required test ordering:
   - Basic structure tests first
   - State management tests second
   - User interaction tests last
7. Use the Mirror Reflection pattern: `Mirror(reflecting: view.body).descendant('content')`
8. Implement async tests for SwiftUI views using the syntax:
   ```swift
   @Test func testViewState() async throws
   let view = await HomeView()
   ```

## 2. Test-Driven Development Implementation

9. Use the `@Test` macro for all test methods
10. Implement assertions with `#expect`
11. Handle optional unwrapping with `#require`
12. Create parameterized tests where applicable
13. Use appropriate test traits for all test cases
14. Group related tests together with descriptive naming
15. Apply appropriate tags to tests
16. Properly handle asynchronous tests
17. Follow the TDD workflow:
    - Write failing tests first
    - Create minimal code to pass tests
    - Refactor while maintaining test integrity
18. Always include `@testable import magical_stories` in test files
19. Remember that test target and app target are different and require explicit imports

## 3. Documentation Requirements

20. Update architecture documentation when making architectural changes:
    - documents/technical/architecture-overview.md
    - documents/project/technical-roadmap.md
    - documents/development/project-plan.md
21. Update API integration documentation when modifying integrations:
    - documents/api/google-ai-integration.md
    - documents/api/storekit-integration.md
22. Update data model documentation when changing data structures:
    - documents/data/swift-data-schema.md
    - documents/data/persistence-guide.md
23. Update security documentation when modifying security aspects:
    - documents/security/security-guidelines.md
    - documents/security/privacy-compliance.md
24. Update UI/UX documentation when changing interface elements:
    - documents/ui/design-system.md
    - documents/ui/accessibility.md
25. Update feature documentation when implementing or modifying features:
    - documents/MVP-requirements.md
    - documents/Growth-Path-Stories.md
    - documents/App-structure.md

## 4. Review Process Rules

26. Verify all affected documentation has been updated
27. Ensure changes have been reviewed with the team
28. Update version numbers when applicable
29. Validate all code examples in documentation

## 5. Technical Implementation Rules

30. Within the same target, do not add unnecessary imports for views and components
31. Only import external modules/frameworks not in the same target
32. Do not rely solely on IDE linter errors for validation
33. Be aware that complex Swift features, generic types, or property wrappers may trigger false linter errors
34. Always build the project to validate code correctness
35. Prioritize build errors over linter errors in complex Swift code
36. Remember that some Swift language features cause false positive linter errors