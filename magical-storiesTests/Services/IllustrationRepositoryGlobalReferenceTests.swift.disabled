import XCTest
import Foundation
@testable import magical_stories

/// Tests for IllustrationTaskRepository methods specific to global reference task storage and retrieval
class IllustrationRepositoryGlobalReferenceTests: XCTestCase {
    
    // MARK: - Test Properties
    
    private var mockRepository: MockIllustrationTaskRepository!
    
    // Test data
    private let testStoryId = UUID()
    private let testPageIds = [UUID(), UUID(), UUID()]
    
    // MARK: - Setup and Teardown
    
    override func setUp() {
        super.setUp()
        mockRepository = MockIllustrationTaskRepository()
        mockRepository.reset()
    }
    
    override func tearDown() {
        mockRepository = nil
        super.tearDown()
    }
    
    // MARK: - Global Reference Task Storage Tests
    
    func testSaveGlobalReferenceTask() throws {
        // Given
        let globalTaskId = UUID()
        let globalTask = IllustrationTask(
            id: globalTaskId,
            storyId: testStoryId,
            pageId: nil, // Global reference has no specific page
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            attemptCount: 0
        )
        
        // When
        let savedTask = try mockRepository.saveTask(
            globalTask,
            pageNumber: 0, // Global reference is always page 0
            totalPages: 5,
            description: "Global character reference sheet for story consistency",
            previousIllustrationPath: nil // No previous illustration for global reference
        )
        
        // Then
        XCTAssertEqual(savedTask.id, globalTaskId, 
                      "Saved task should have correct ID")
        XCTAssertEqual(savedTask.storyId, testStoryId, 
                      "Saved task should have correct story ID")
        XCTAssertNil(savedTask.pageId, 
                    "Global reference should not have page ID")
        XCTAssertEqual(savedTask.type, .globalReference, 
                      "Saved task should maintain global reference type")
        XCTAssertEqual(savedTask.pageNumber, 0, 
                      "Global reference should be stored as page 0")
        XCTAssertEqual(savedTask.totalPages, 5, 
                      "Should store total pages count")
        XCTAssertEqual(savedTask.illustrationDescription, "Global character reference sheet for story consistency", 
                      "Should store description")
        XCTAssertNil(savedTask.previousIllustrationPath, 
                    "Global reference should not have previous illustration path")
        XCTAssertEqual(savedTask.status, .pending, 
                      "Should maintain pending status")
        XCTAssertEqual(savedTask.priority, .high, 
                      "Should maintain high priority")
        
        // Verify repository tracking
        XCTAssertTrue(mockRepository.savedTasks.keys.contains(globalTaskId), 
                     "Repository should track saved global reference task")
    }
    
    func testSaveMultipleGlobalReferenceTasksForDifferentStories() throws {
        // Given
        let story1Id = UUID()
        let story2Id = UUID()
        
        let globalTask1 = IllustrationTask(
            id: UUID(),
            storyId: story1Id,
            pageId: nil,
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            attemptCount: 0
        )
        
        let globalTask2 = IllustrationTask(
            id: UUID(),
            storyId: story2Id,
            pageId: nil,
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            attemptCount: 0
        )
        
        // When
        let savedTask1 = try mockRepository.saveTask(
            globalTask1,
            pageNumber: 0,
            totalPages: 3,
            description: "Global reference for adventure story",
            previousIllustrationPath: nil
        )
        
        let savedTask2 = try mockRepository.saveTask(
            globalTask2,
            pageNumber: 0,
            totalPages: 4,
            description: "Global reference for fairy tale",
            previousIllustrationPath: nil
        )
        
        // Then
        XCTAssertEqual(savedTask1.storyId, story1Id, 
                      "First task should be associated with story 1")
        XCTAssertEqual(savedTask2.storyId, story2Id, 
                      "Second task should be associated with story 2")
        XCTAssertEqual(savedTask1.totalPages, 3, 
                      "First task should have correct total pages")
        XCTAssertEqual(savedTask2.totalPages, 4, 
                      "Second task should have correct total pages")
        XCTAssertEqual(mockRepository.savedTasks.count, 2, 
                      "Repository should track both global reference tasks")
    }
    
    // MARK: - Global Reference Task Retrieval Tests
    
    func testGetGlobalReferenceTaskById() throws {
        // Given
        let globalTaskId = UUID()
        let globalTask = PendingIllustrationTask(
            id: globalTaskId,
            storyId: testStoryId,
            pageId: nil,
            type: .globalReference,
            status: .completed,
            priority: .high,
            maxAttempts: 3,
            attemptCount: 1,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 0,
            totalPages: 3,
            illustrationDescription: "Character reference sheet",
            previousIllustrationPath: nil
        )
        
        mockRepository.taskToReturn = globalTask
        
        // When
        let retrievedTask = try mockRepository.getTaskById(globalTaskId)
        
        // Then
        XCTAssertNotNil(retrievedTask, "Should retrieve global reference task")
        XCTAssertEqual(retrievedTask?.id, globalTaskId, "Should retrieve correct task")
        XCTAssertEqual(retrievedTask?.type, .globalReference, "Should maintain global reference type")
        XCTAssertEqual(retrievedTask?.pageNumber, 0, "Should maintain page number 0")
        XCTAssertNil(retrievedTask?.pageId, "Should not have page ID")
        XCTAssertEqual(retrievedTask?.status, .completed, "Should maintain completed status")
        XCTAssertTrue(mockRepository.fetchedById.contains(globalTaskId), 
                     "Repository should track fetch operation")
    }
    
    func testGetGlobalReferenceTasksForStory() throws {
        // Given
        let globalTask = PendingIllustrationTask(
            id: UUID(),
            storyId: testStoryId,
            pageId: nil,
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            attemptCount: 0,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 0,
            totalPages: 4,
            illustrationDescription: "Global reference",
            previousIllustrationPath: nil
        )
        
        let pageTask = PendingIllustrationTask(
            id: UUID(),
            storyId: testStoryId,
            pageId: testPageIds[0],
            type: .pageIllustration,
            status: .pending,
            priority: .medium,
            maxAttempts: 3,
            attemptCount: 0,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 1,
            totalPages: 4,
            illustrationDescription: "Page 1 illustration",
            previousIllustrationPath: nil
        )
        
        mockRepository.tasksToReturn = [globalTask, pageTask]
        
        // When
        let storyTasks = try mockRepository.getTasksForStory(testStoryId)
        
        // Then
        XCTAssertEqual(storyTasks.count, 2, "Should retrieve both tasks for story")
        
        let globalTasks = storyTasks.filter { $0.type == .globalReference }
        XCTAssertEqual(globalTasks.count, 1, "Should find one global reference task")
        
        let retrievedGlobalTask = globalTasks.first!
        XCTAssertEqual(retrievedGlobalTask.pageNumber, 0, "Global reference should be page 0")
        XCTAssertNil(retrievedGlobalTask.pageId, "Global reference should not have page ID")
        XCTAssertEqual(retrievedGlobalTask.storyId, testStoryId, "Should be associated with correct story")
        
        XCTAssertTrue(mockRepository.fetchedByStory.contains(testStoryId), 
                     "Repository should track story fetch operation")
    }
    
    func testGetAllPendingTasksIncludesGlobalReference() throws {
        // Given
        let globalTask1 = PendingIllustrationTask(
            id: UUID(),
            storyId: testStoryId,
            pageId: nil,
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            attemptCount: 0,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 0,
            totalPages: 3,
            illustrationDescription: "Global reference 1",
            previousIllustrationPath: nil
        )
        
        let globalTask2 = PendingIllustrationTask(
            id: UUID(),
            storyId: UUID(), // Different story
            pageId: nil,
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            attemptCount: 0,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 0,
            totalPages: 2,
            illustrationDescription: "Global reference 2",
            previousIllustrationPath: nil
        )
        
        let pageTask = PendingIllustrationTask(
            id: UUID(),
            storyId: testStoryId,
            pageId: testPageIds[0],
            type: .pageIllustration,
            status: .pending,
            priority: .medium,
            maxAttempts: 3,
            attemptCount: 0,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 1,
            totalPages: 3,
            illustrationDescription: "Page illustration",
            previousIllustrationPath: nil
        )
        
        mockRepository.tasksToReturn = [globalTask1, globalTask2, pageTask]
        
        // When
        let allPendingTasks = try mockRepository.getAllPendingTasks()
        
        // Then
        XCTAssertEqual(allPendingTasks.count, 3, "Should retrieve all pending tasks")
        
        let globalTasks = allPendingTasks.filter { $0.type == .globalReference }
        XCTAssertEqual(globalTasks.count, 2, "Should include both global reference tasks")
        
        let pageTasks = allPendingTasks.filter { $0.type == .pageIllustration }
        XCTAssertEqual(pageTasks.count, 1, "Should include page illustration task")
        
        // Verify all global reference tasks have correct properties
        for globalTask in globalTasks {
            XCTAssertEqual(globalTask.pageNumber, 0, "Global reference should be page 0")
            XCTAssertNil(globalTask.pageId, "Global reference should not have page ID")
            XCTAssertEqual(globalTask.priority, .high, "Global reference should have high priority")
            XCTAssertNil(globalTask.previousIllustrationPath, "Global reference should not have previous illustration")
        }
        
        XCTAssertTrue(mockRepository.fetchedAllPending, 
                     "Repository should track getAllPending operation")
    }
    
    // MARK: - Global Reference Task Update Tests
    
    func testUpdateGlobalReferenceTaskStatus() throws {
        // Given
        let globalTaskId = UUID()
        let updatedTask = PendingIllustrationTask(
            id: globalTaskId,
            storyId: testStoryId,
            pageId: nil,
            type: .globalReference,
            status: .completed, // Updated status
            priority: .high,
            maxAttempts: 3,
            attemptCount: 1,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 0,
            totalPages: 3,
            illustrationDescription: "Global reference completed",
            previousIllustrationPath: nil
        )
        
        mockRepository.taskToReturn = updatedTask
        
        // When
        let result = try mockRepository.updateTaskStatus(globalTaskId, status: .completed)
        
        // Then
        XCTAssertNotNil(result, "Should return updated task")
        XCTAssertEqual(result?.id, globalTaskId, "Should update correct task")
        XCTAssertEqual(result?.status, .completed, "Should update status to completed")
        XCTAssertEqual(result?.type, .globalReference, "Should maintain global reference type")
        XCTAssertTrue(mockRepository.updatedStatuses.keys.contains(globalTaskId), 
                     "Repository should track status update")
        XCTAssertEqual(mockRepository.updatedStatuses[globalTaskId], .completed, 
                      "Repository should track correct status")
    }
    
    func testIncrementGlobalReferenceTaskAttempt() throws {
        // Given
        let globalTaskId = UUID()
        let updatedTask = PendingIllustrationTask(
            id: globalTaskId,
            storyId: testStoryId,
            pageId: nil,
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            attemptCount: 2, // Incremented attempt
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 0,
            totalPages: 3,
            illustrationDescription: "Global reference retry",
            previousIllustrationPath: nil
        )
        
        mockRepository.taskToReturn = updatedTask
        
        // When
        let result = try mockRepository.incrementTaskAttempt(globalTaskId)
        
        // Then
        XCTAssertNotNil(result, "Should return updated task")
        XCTAssertEqual(result?.id, globalTaskId, "Should update correct task")
        XCTAssertEqual(result?.attemptCount, 2, "Should increment attempt count")
        XCTAssertEqual(result?.type, .globalReference, "Should maintain global reference type")
        XCTAssertTrue(mockRepository.incrementedAttempts.contains(globalTaskId), 
                     "Repository should track attempt increment")
    }
    
    // MARK: - Global Reference Task Deletion Tests
    
    func testDeleteGlobalReferenceTask() throws {
        // Given
        let globalTaskId = UUID()
        
        // When
        try mockRepository.deleteTask(globalTaskId)
        
        // Then
        XCTAssertTrue(mockRepository.deletedTasks.contains(globalTaskId), 
                     "Repository should track global reference task deletion")
    }
    
    func testDeleteTasksForStoryIncludesGlobalReference() throws {
        // Given
        let storyId = testStoryId
        
        // When
        try mockRepository.deleteTasksForStory(storyId)
        
        // Then
        XCTAssertTrue(mockRepository.deletedTasksForStory.contains(storyId), 
                     "Repository should track story deletion including global reference")
    }
    
    // MARK: - Task Manager Restoration Tests
    
    func testRestoreGlobalReferenceTasksToManager() async throws {
        // Given
        let taskManager = IllustrationTaskManager()
        
        let globalTask = PendingIllustrationTask(
            id: UUID(),
            storyId: testStoryId,
            pageId: nil,
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            attemptCount: 0,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 0,
            totalPages: 3,
            illustrationDescription: "Restored global reference",
            previousIllustrationPath: nil
        )
        
        let pageTask = PendingIllustrationTask(
            id: UUID(),
            storyId: testStoryId,
            pageId: testPageIds[0],
            type: .pageIllustration,
            status: .pending,
            priority: .medium,
            maxAttempts: 3,
            attemptCount: 0,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            pageNumber: 1,
            totalPages: 3,
            illustrationDescription: "Restored page task",
            previousIllustrationPath: nil
        )
        
        mockRepository.tasksToReturn = [globalTask, pageTask]
        
        // When
        let restoredCount = try await mockRepository.restoreTasksToManager(taskManager)
        
        // Then
        XCTAssertEqual(restoredCount, 2, "Should restore both tasks")
        XCTAssertTrue(mockRepository.fetchedAllPending, 
                     "Repository should fetch all pending tasks for restoration")
        
        // Verify tasks are restored to manager in correct order
        let nextTask = taskManager.getNextTask()
        XCTAssertEqual(nextTask?.type, .globalReference, 
                      "Global reference should be first task from manager")
        XCTAssertEqual(nextTask?.id, globalTask.id, 
                      "Should restore correct global reference task")
    }
    
    // MARK: - Error Handling Tests
    
    func testSaveGlobalReferenceTaskWithError() {
        // Given
        let globalTask = IllustrationTask(
            id: UUID(),
            storyId: testStoryId,
            pageId: nil,
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            attemptCount: 0
        )
        
        mockRepository.shouldThrowError = true
        mockRepository.errorToThrow = NSError(domain: "TestError", code: 500, userInfo: [NSLocalizedDescriptionKey: "Database save error"])
        
        // When/Then
        XCTAssertThrowsError(try mockRepository.saveTask(globalTask, pageNumber: 0, totalPages: 3, description: "Test", previousIllustrationPath: nil)) { error in
            XCTAssertEqual((error as NSError).domain, "TestError", "Should throw configured error")
            XCTAssertEqual((error as NSError).code, 500, "Should maintain error code")
        }
    }
    
    func testRetrieveGlobalReferenceTaskWithError() {
        // Given
        let globalTaskId = UUID()
        mockRepository.shouldThrowError = true
        mockRepository.errorToThrow = NSError(domain: "TestError", code: 404, userInfo: [NSLocalizedDescriptionKey: "Task not found"])
        
        // When/Then
        XCTAssertThrowsError(try mockRepository.getTaskById(globalTaskId)) { error in
            XCTAssertEqual((error as NSError).domain, "TestError", "Should throw configured error")
            XCTAssertEqual((error as NSError).code, 404, "Should maintain error code")
        }
    }
    
    // MARK: - Global Reference Task Validation Tests
    
    func testGlobalReferenceTaskPropertiesValidation() throws {
        // Given
        let globalTask = IllustrationTask(
            id: UUID(),
            storyId: testStoryId,
            pageId: nil, // Must be nil for global reference
            type: .globalReference,
            status: .pending,
            priority: .high, // Should be high priority
            maxAttempts: 3,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            attemptCount: 0
        )
        
        // When
        let savedTask = try mockRepository.saveTask(
            globalTask,
            pageNumber: 0, // Must be 0 for global reference
            totalPages: 5,
            description: "Global character reference sheet",
            previousIllustrationPath: nil // Must be nil for global reference
        )
        
        // Then - Verify all global reference constraints
        XCTAssertNil(savedTask.pageId, 
                    "Global reference must not have page ID")
        XCTAssertEqual(savedTask.pageNumber, 0, 
                      "Global reference must be page 0")
        XCTAssertNil(savedTask.previousIllustrationPath, 
                    "Global reference must not have previous illustration")
        XCTAssertEqual(savedTask.type, .globalReference, 
                      "Must maintain global reference type")
        XCTAssertEqual(savedTask.priority, .high, 
                      "Global reference should have high priority")
        XCTAssertNotNil(savedTask.illustrationDescription, 
                       "Global reference should have description")
    }
    
    // MARK: - Integration Test - Complete Global Reference Repository Flow
    
    func testCompleteGlobalReferenceRepositoryFlow() throws {
        // Given - A complete story setup with global reference and page tasks
        let storyId = UUID()
        let pageIds = [UUID(), UUID()]
        
        // Create global reference task
        let globalTask = IllustrationTask(
            id: UUID(),
            storyId: storyId,
            pageId: nil,
            type: .globalReference,
            status: .pending,
            priority: .high,
            maxAttempts: 3,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            attemptCount: 0
        )
        
        // Create page tasks
        let pageTask1 = IllustrationTask(
            id: UUID(),
            storyId: storyId,
            pageId: pageIds[0],
            type: .pageIllustration,
            status: .pending,
            priority: .medium,
            maxAttempts: 3,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            attemptCount: 0
        )
        
        let pageTask2 = IllustrationTask(
            id: UUID(),
            storyId: storyId,
            pageId: pageIds[1],
            type: .pageIllustration,
            status: .pending,
            priority: .medium,
            maxAttempts: 3,
            createdAt: Date(),
            lastUpdatedAt: Date(),
            attemptCount: 0
        )
        
        // When - Complete repository operations flow
        
        // 1. Save all tasks
        let savedGlobalTask = try mockRepository.saveTask(
            globalTask,
            pageNumber: 0,
            totalPages: 3,
            description: "Comprehensive character reference sheet",
            previousIllustrationPath: nil
        )
        
        let savedPageTask1 = try mockRepository.saveTask(
            pageTask1,
            pageNumber: 1,
            totalPages: 3,
            description: "Page 1 illustration",
            previousIllustrationPath: nil
        )
        
        let savedPageTask2 = try mockRepository.saveTask(
            pageTask2,
            pageNumber: 2,
            totalPages: 3,
            description: "Page 2 illustration",
            previousIllustrationPath: "page1-illustration-path"
        )
        
        // 2. Update global reference task status
        mockRepository.taskToReturn = savedGlobalTask
        let updatedGlobalTask = try mockRepository.updateTaskStatus(globalTask.id, status: .inProgress)
        
        // 3. Complete global reference task
        mockRepository.taskToReturn = PendingIllustrationTask(
            id: globalTask.id,
            storyId: storyId,
            pageId: nil,
            type: .globalReference,
            status: .completed,
            priority: .high,
            maxAttempts: 3,
            attemptCount: 1,
            createdAt: globalTask.createdAt,
            lastUpdatedAt: Date(),
            pageNumber: 0,
            totalPages: 3,
            illustrationDescription: "Comprehensive character reference sheet",
            previousIllustrationPath: nil
        )
        let completedGlobalTask = try mockRepository.updateTaskStatus(globalTask.id, status: .completed)
        
        // 4. Retrieve all tasks for story
        mockRepository.tasksToReturn = [savedGlobalTask, savedPageTask1, savedPageTask2]
        let allStoryTasks = try mockRepository.getTasksForStory(storyId)
        
        // Then - Verify complete flow
        
        // Verify saving
        XCTAssertEqual(mockRepository.savedTasks.count, 3, 
                      "Should save all tasks")
        XCTAssertTrue(mockRepository.savedTasks.keys.contains(globalTask.id), 
                     "Should save global reference task")
        
        // Verify global reference properties
        XCTAssertEqual(savedGlobalTask.pageNumber, 0, 
                      "Global reference should be page 0")
        XCTAssertNil(savedGlobalTask.pageId, 
                    "Global reference should not have page ID")
        XCTAssertNil(savedGlobalTask.previousIllustrationPath, 
                    "Global reference should not have previous illustration")
        
        // Verify status updates
        XCTAssertNotNil(updatedGlobalTask, 
                       "Should update global reference status")
        XCTAssertNotNil(completedGlobalTask, 
                       "Should complete global reference task")
        XCTAssertTrue(mockRepository.updatedStatuses.keys.contains(globalTask.id), 
                     "Should track global reference status updates")
        
        // Verify retrieval
        XCTAssertEqual(allStoryTasks.count, 3, 
                      "Should retrieve all story tasks")
        
        let retrievedGlobalTasks = allStoryTasks.filter { $0.type == .globalReference }
        XCTAssertEqual(retrievedGlobalTasks.count, 1, 
                      "Should retrieve exactly one global reference task")
        
        let retrievedPageTasks = allStoryTasks.filter { $0.type == .pageIllustration }
        XCTAssertEqual(retrievedPageTasks.count, 2, 
                      "Should retrieve all page illustration tasks")
        
        // Verify ordering by page number
        let orderedTasks = allStoryTasks.sorted { $0.pageNumber < $1.pageNumber }
        XCTAssertEqual(orderedTasks[0].type, .globalReference, 
                      "Global reference should be first in page order")
        XCTAssertEqual(orderedTasks[1].pageNumber, 1, 
                      "First page task should be second in order")
        XCTAssertEqual(orderedTasks[2].pageNumber, 2, 
                      "Second page task should be third in order")
        
        // Verify repository operation tracking
        XCTAssertTrue(mockRepository.fetchedByStory.contains(storyId), 
                     "Should track story fetch operation")
    }
}