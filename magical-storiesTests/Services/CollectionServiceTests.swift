import Testing\n@testable import magical_stories\nimport Foundation\nimport SwiftUI // For MainActor\n\n@MainActor\nstruct CollectionServiceTests {\n\n    var collectionService: CollectionService!\n    var mockStoryService: MockStoryService!\n    var mockPersistenceService: MockPersistenceService!\n    var mockGenerativeModel: MockGenerativeModel!\n    var aiErrorManager: AIErrorManager!\n\n    init() {\n        // Setup instances before each test\n        mockStoryService = MockStoryService()\n        mockPersistenceService = MockPersistenceService()\n        mockGenerativeModel = MockGenerativeModel()\n        aiErrorManager = AIErrorManager() // Assuming no special init needed\n        \n        collectionService = CollectionService(\n            storyService: mockStoryService,\n            persistenceService: mockPersistenceService,\n            aiErrorManager: aiErrorManager,\n            model: mockGenerativeModel\n        )\n    }\n\n    @Test func generateCollection_Success() async throws {\n        // Arrange\n        let parameters = CollectionParameters.example\n        let expectedStories = 5 // From CollectionService.Constants\n        let expectedTitle = \"AI Generated Title\"\n        let expectedDesc = \"AI Generated Description\"\n        let expectedTheme = \"Sharing\"\n        let expectedContext = \"AI Context\"\n        \n        // Configure Mock AI Response\n        let jsonResponse = \"\"\"\n        {\n            \"title\": \"\\(expectedTitle)\",\n            \"description\": \"\\(expectedDesc)\",\n            \"achievementIds\": [\"badge1\"],\n            \"storyOutlines\": [\n                {\"theme\": \"\\(expectedTheme)\", \"context\": \"\\(expectedContext) 1\"},\n                {\"theme\": \"\\(expectedTheme)\", \"context\": \"\\(expectedContext) 2\"},\n                {\"theme\": \"\\(expectedTheme)\", \"context\": \"\\(expectedContext) 3\"},\n                {\"theme\": \"\\(expectedTheme)\", \"context\": \"\\(expectedContext) 4\"},\n                {\"theme\": \"\\(expectedTheme)\", \"context\": \"\\(expectedContext) 5\"}\n            ]\n        }\n        \"\"\"\n        mockGenerativeModel.generateContentHandler = { _ in MockStoryGenerationResponse(text: jsonResponse) }\n        \n        // Configure Mock StoryService Response\n        var generateStoryCallCount = 0\n        mockStoryService.generateStoryHandler = { params in\n            generateStoryCallCount += 1\n            var story = Story.previewStory(title: \"Generated Story \\(generateStoryCallCount)\")\n            story.parameters = params // Ensure params match\n            return story\n        }\n\n        // Act\n        let collection = try await collectionService.generateCollection(parameters: parameters)\n\n        // Assert\n        #expect(collection.title == expectedTitle)\n        #expect(collection.description == expectedDesc)\n        #expect(collection.stories.count == expectedStories)\n        #expect(generateStoryCallCount == expectedStories)\n        #expect(mockGenerativeModel.generateContentCallCount == 1)\n        #expect(mockPersistenceService.savedCollections[collection.id] != nil)\n        #expect(collection.stories.first?.collectionId == collection.id)\n    }\n\n    @Test func generateCollection_AIError_RetriesAndFails() async throws {\n        // Arrange\n        let parameters = CollectionParameters.example\n        var callCount = 0\n        mockGenerativeModel.generateContentHandler = { _ in\n            callCount += 1\n            throw NSError(domain: \"AIError\", code: 123)\n        }\n        \n        // Act & Assert\n        await #expect(throws: (any Error).self) { // Expect *any* error after retries\n            _ = try await collectionService.generateCollection(parameters: parameters)\n        }\n        \n        // Verify retries (Constants.maxRetries is 3, so 3 calls)\n        #expect(callCount == 3)\n    }\n\n    @Test func generateCollection_JSONParsingError_RetriesAndFails() async throws {\n        // Arrange\n        let parameters = CollectionParameters.example\n        var callCount = 0\n        mockGenerativeModel.generateContentHandler = { _ in\n            callCount += 1\n            return MockStoryGenerationResponse(text: \"{invalid json\") // Malformed JSON\n        }\n        \n        // Act & Assert\n        await #expect(throws: CollectionError.self) { // Expect a specific CollectionError\n            _ = try await collectionService.generateCollection(parameters: parameters)\n        }\ catch let error as CollectionError {\n            // Check if the underlying error indicates parsing failure\n             guard case .aiServiceError(let underlyingError) = error else {\n                 Issue.record(\"Expected .aiServiceError, got \\(error)\")\n                 return\n             }\n             #expect(underlyingError is DecodingError)\n        } \n        \n        #expect(callCount == 3)\n    }\n    \n    @Test func generateCollection_IncorrectOutlineCount_RetriesAndFails() async throws {\n         // Arrange\n         let parameters = CollectionParameters.example\n         var callCount = 0\n         let jsonResponse = \"\"\"\n         {\n             \"title\": \"Test Title\",\n             \"description\": \"Test Desc\",\n             \"storyOutlines\": [ {\"theme\": \"T\", \"context\": \"C\"} ] // Only 1 outline\n         }\n         \"\"\"\n         mockGenerativeModel.generateContentHandler = { _ in\n             callCount += 1\n             return MockStoryGenerationResponse(text: jsonResponse)\n         }\n         \n         // Act & Assert\n         await #expect(throws: CollectionError.self) {\n             _ = try await collectionService.generateCollection(parameters: parameters)\n         } catch let error as CollectionError {\n             guard case .aiServiceError(let underlyingError) = error else {\n                 Issue.record(\"Expected .aiServiceError for wrong count, got \\(error)\")\n                 return\n             }\n             // Check the underlying error description contains expected count info\n             #expect(underlyingError?.localizedDescription.contains(\"incorrect number of story outlines\") ?? false)\n         }\n         \n         #expect(callCount == 3)\n     }\n\n    @Test func updateProgress_Success() async throws {\n        // Arrange\n        let collection = GrowthCollection.previewExample\n        mockPersistenceService.savedCollections[collection.id] = collection\n        await collectionService.loadCollections() // Load into service's state\n        let newProgress: Float = 0.8\n        \n        // Act\n        try await collectionService.updateProgress(for: collection.id, progress: newProgress)\n        \n        // Assert\n        #expect(collectionService.collections.first?.progress == newProgress)\n        #expect(mockPersistenceService.savedCollections[collection.id]?.progress == newProgress)\n    }\n\n    @Test func updateProgress_CollectionNotFound() async throws {\n        // Arrange\n        let nonExistentId = UUID()\n        \n        // Act & Assert\n        await #expect(throws: CollectionError.collectionNotFound) {\n            try await collectionService.updateProgress(for: nonExistentId, progress: 0.5)\n        }\n    }\n\n    @Test func checkAchievements_AwardsProgressBadges() async throws {\n        // Arrange\n        let collection = GrowthCollection.previewExample // Progress is 0.66\n        let quarterBadgeId = UUID(uuidString: CollectionService.Constants.progressThresholds[0.25]!)!\n        let halfBadgeId = UUID(uuidString: CollectionService.Constants.progressThresholds[0.50]!)!\n        let almostBadgeId = UUID(uuidString: CollectionService.Constants.progressThresholds[0.75]!)!\n        \n        // Setup achievements in mock persistence (not yet earned)\n        mockPersistenceService.savedAchievements[quarterBadgeId] = Achievement(id: quarterBadgeId, name: \"Quarter\", type: .growthPathProgress)\n        mockPersistenceService.savedAchievements[halfBadgeId] = Achievement(id: halfBadgeId, name: \"Half\", type: .growthPathProgress)\n        mockPersistenceService.savedAchievements[almostBadgeId] = Achievement(id: almostBadgeId, name: \"Almost\", type: .growthPathProgress)\n        \n        // Put collection into service state\n        mockPersistenceService.savedCollections[collection.id] = collection\n        await collectionService.loadCollections()\n        \n        // Act\n        let newAchievements = try await collectionService.checkAchievements(for: collection.id)\n        \n        // Assert\n        #expect(newAchievements.count == 2)\n        #expect(newAchievements.contains { $0.id == quarterBadgeId })\n        #expect(newAchievements.contains { $0.id == halfBadgeId })\n        #expect(!newAchievements.contains { $0.id == almostBadgeId })\n        // Check if they were saved as earned in persistence\n        #expect(mockPersistenceService.savedAchievements[quarterBadgeId]?.dateEarned != nil)\n        #expect(mockPersistenceService.savedAchievements[halfBadgeId]?.dateEarned != nil)\n    }\n    \n     @Test func checkAchievements_AwardsCollectionSpecificBadgeAtCompletion() async throws {\n         // Arrange\n         let badgeIdString = \"final_boss_badge\"\n         let badgeUUID = UUID() // Use a specific UUID for predictability\n         var collection = GrowthCollection.previewExample\n         collection.progress = 1.0 // Set progress to complete\n         collection.associatedBadges = [badgeIdString] // Add the specific badge ID\n         \n         // Mock achievement (not earned)\n         mockPersistenceService.savedAchievements[badgeUUID] = Achievement(id: badgeUUID, name: \"Final Boss\", type: .specialMilestone)\n         \n         // Hacky way to associate string ID with UUID for this test\n         // In real app, IDs would likely be consistent UUIDs\n         CollectionService.Constants.progressThresholds[1.0] = badgeUUID.uuidString // Temporarily map\n \n         mockPersistenceService.savedCollections[collection.id] = collection\n         await collectionService.loadCollections()\n         \n         // Act\n         let newAchievements = try await collectionService.checkAchievements(for: collection.id)\n         \n         // Assert\n         // Should include progress badges AND the specific one\n         #expect(newAchievements.contains { $0.id == badgeUUID })\n         #expect(mockPersistenceService.savedAchievements[badgeUUID]?.dateEarned != nil)\n         \n         // Clean up temporary mapping if necessary, though test instance is ephemeral\n     }\n}\n 